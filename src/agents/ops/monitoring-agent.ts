/**
 * Monitoring Agent
 *
 * Specializes in health check monitoring, metrics collection, and alert generation.
 * Watches deployed services and notifies IncidentAgent of failures.
 *
 * Part of Phase 6c-6e: MonitoringAgent and IncidentAgent
 */

import { Agent, AgentConfig } from '../base/agent.js';
import { Task, TaskResult } from '../../core/tasks/types.js';
import { Tool } from '../../core/tools/types.js';
import { LLMClient } from '../../core/llm/client.js';

const MONITORING_SYSTEM_PROMPT = `You are a Monitoring Agent. You watch services, detect failures, and generate alerts.

## Core Responsibilities

1. **Health Monitoring**: Continuously check service health endpoints
2. **Failure Detection**: Identify when services become unhealthy
3. **Alert Generation**: Create alerts when failures exceed thresholds
4. **Metrics Collection**: Track uptime, latency, and error rates

## Health Check Process

1. Call health_check on each target endpoint
2. Track consecutive failures for each target
3. When failures >= threshold, create an alert
4. Report health status and any detected issues

## Alert Thresholds

- 3 consecutive failures: Create incident alert
- 5 consecutive failures: High priority alert
- 10 consecutive failures: Critical alert

## Tools Reference

| Tool | Use For |
|------|---------|
| health_check | Check if endpoint is healthy |
| read_wiki | Get runbook or configuration |
| write_wiki | Log monitoring results |

## Output Format

After monitoring, report:
- Targets checked: [count]
- Healthy: [list]
- Unhealthy: [list]
- Alerts created: [count]

If you detect failures that require attention, clearly indicate:
- ALERT: [Service Name] - [Failure Reason]`;

/**
 * Health check target configuration
 */
export interface MonitoringTarget {
  name: string;
  url: string;
  healthEndpoint: string;
  checkInterval: number;
}

/**
 * Health state for a monitored target
 */
export interface HealthState {
  target: string;
  consecutiveFailures: number;
  lastCheck: Date | null;
  lastStatus: 'healthy' | 'unhealthy' | 'unknown';
  lastError?: string;
}

/**
 * Alert generated by monitoring
 */
export interface MonitoringAlert {
  id: string;
  target: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  timestamp: Date;
  consecutiveFailures: number;
}

export interface MonitoringAgentConfig {
  name?: string;
  llmClient: LLMClient;
  tools: Tool[];
  workspace: string;
  alertThreshold?: number;
  targets?: MonitoringTarget[];
}

export class MonitoringAgent extends Agent {
  private workspace: string;
  private alertThreshold: number;
  private targets: MonitoringTarget[];
  private healthStates: Map<string, HealthState>;
  private alerts: MonitoringAlert[];

  constructor(config: MonitoringAgentConfig) {
    const agentConfig: AgentConfig = {
      name: config.name ?? 'MonitoringAgent',
      role: 'Monitoring Engineer',
      systemPrompt: MONITORING_SYSTEM_PROMPT,
      llmClient: config.llmClient,
      tools: config.tools,
    };
    super(agentConfig);
    this.workspace = config.workspace;
    this.alertThreshold = config.alertThreshold ?? 3;
    // Copy the targets array to avoid mutating the original
    this.targets = [...(config.targets ?? [])];
    this.healthStates = new Map();
    this.alerts = [];

    // Initialize health states for all targets
    for (const target of this.targets) {
      this.healthStates.set(target.name, {
        target: target.name,
        consecutiveFailures: 0,
        lastCheck: null,
        lastStatus: 'unknown',
      });
    }
  }

  /**
   * Execute a monitoring task
   */
  async executeTask(task: Task): Promise<TaskResult> {
    console.log(`[${this.name}] === TASK START: ${task.title} ===`);

    try {
      // Process the task with LLM assistance
      const prompt = this.buildTaskPrompt(task);
      const response = await this.processMessageWithTools(prompt, 5);

      // Analyze response for any actions taken
      const success = this.analyzeMonitoringResponse(response);

      return {
        success,
        output: response,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Build a prompt for the monitoring task
   */
  private buildTaskPrompt(task: Task): string {
    let prompt = `## Task: ${task.title}\n\n`;
    prompt += `**Description**:\n${task.description}\n\n`;

    if (task.context) {
      prompt += `**Context**:\n${JSON.stringify(task.context, null, 2)}\n\n`;
    }

    prompt += `**Workspace**: ${this.workspace}\n\n`;

    // Add target information
    if (this.targets.length > 0) {
      prompt += `## Monitoring Targets\n\n`;
      for (const target of this.targets) {
        const state = this.healthStates.get(target.name);
        prompt += `- **${target.name}**: ${target.url}${target.healthEndpoint}`;
        if (state) {
          prompt += ` (Status: ${state.lastStatus}, Failures: ${state.consecutiveFailures})`;
        }
        prompt += '\n';
      }
      prompt += '\n';
    }

    // Add current alerts
    const pendingAlerts = this.alerts.filter(a => !a.message.includes('resolved'));
    if (pendingAlerts.length > 0) {
      prompt += `## Pending Alerts\n\n`;
      for (const alert of pendingAlerts) {
        prompt += `- [${alert.severity.toUpperCase()}] ${alert.target}: ${alert.message}\n`;
      }
      prompt += '\n';
    }

    return prompt;
  }

  /**
   * Analyze monitoring response
   */
  private analyzeMonitoringResponse(response: string): boolean {
    const lowerResponse = response.toLowerCase();

    // Check for monitoring success indicators
    const successIndicators = [
      'checked',
      'monitored',
      'healthy',
      'all targets healthy',
      'no issues detected',
    ];

    const hasSuccess = successIndicators.some(ind => lowerResponse.includes(ind));

    // Check for failures that were detected and reported
    const alertIndicators = [
      'alert:',
      'alert created',
      'failure detected',
      'unhealthy',
    ];

    const hasAlert = alertIndicators.some(ind => lowerResponse.includes(ind));

    // Monitoring is successful if either:
    // 1. All targets are healthy
    // 2. Failures were detected and alerts were created
    return hasSuccess || hasAlert;
  }

  /**
   * Add a monitoring target
   */
  addTarget(target: MonitoringTarget): void {
    this.targets.push(target);
    this.healthStates.set(target.name, {
      target: target.name,
      consecutiveFailures: 0,
      lastCheck: null,
      lastStatus: 'unknown',
    });
  }

  /**
   * Remove a monitoring target
   */
  removeTarget(name: string): boolean {
    const index = this.targets.findIndex(t => t.name === name);
    if (index >= 0) {
      this.targets.splice(index, 1);
      this.healthStates.delete(name);
      return true;
    }
    return false;
  }

  /**
   * Get all monitoring targets
   */
  getTargets(): MonitoringTarget[] {
    return [...this.targets];
  }

  /**
   * Record a health check result
   */
  recordHealthCheck(targetName: string, isHealthy: boolean, error?: string): void {
    const state = this.healthStates.get(targetName);
    if (!state) return;

    if (isHealthy) {
      state.consecutiveFailures = 0;
      state.lastStatus = 'healthy';
      state.lastError = undefined;
    } else {
      state.consecutiveFailures++;
      state.lastStatus = 'unhealthy';
      state.lastError = error;

      // Check if we should create an alert
      if (state.consecutiveFailures >= this.alertThreshold) {
        this.createAlert(targetName, state.consecutiveFailures, error);
      }
    }

    state.lastCheck = new Date();
    this.healthStates.set(targetName, state);
  }

  /**
   * Create an alert for a failed target
   */
  private createAlert(targetName: string, failures: number, error?: string): void {
    // Determine severity based on consecutive failures
    let severity: MonitoringAlert['severity'] = 'medium';
    if (failures >= 10) severity = 'critical';
    else if (failures >= 5) severity = 'high';
    else if (failures >= 3) severity = 'medium';

    const alert: MonitoringAlert = {
      id: `ALERT-${Date.now()}`,
      target: targetName,
      severity,
      message: `Health check failed ${failures} consecutive times${error ? `: ${error}` : ''}`,
      timestamp: new Date(),
      consecutiveFailures: failures,
    };

    this.alerts.push(alert);
    console.log(`[${this.name}] ALERT: ${alert.target} - ${alert.message}`);
  }

  /**
   * Get all pending alerts
   */
  getAlerts(): MonitoringAlert[] {
    return [...this.alerts];
  }

  /**
   * Get health state for a target
   */
  getHealthState(targetName: string): HealthState | undefined {
    return this.healthStates.get(targetName);
  }

  /**
   * Get all health states
   */
  getAllHealthStates(): HealthState[] {
    return Array.from(this.healthStates.values());
  }

  /**
   * Clear resolved alerts
   */
  clearResolvedAlerts(): void {
    this.alerts = this.alerts.filter(a => {
      const state = this.healthStates.get(a.target);
      return state && state.lastStatus === 'unhealthy';
    });
  }

  /**
   * Get workspace path
   */
  getWorkspace(): string {
    return this.workspace;
  }
}
